// File: top.v
// Generated by MyHDL 0.11
// Date: Mon Feb 24 14:37:10 2020


`timescale 1ns/10ps

module top (
    rxd_uart,
    txd_uart,
    oled,
    seg,
    segdp,
    dip_sw,
    reset_n,
    clk_in
);


input rxd_uart;
input txd_uart;
output [7:0] oled;
wire [7:0] oled;
output [12:0] seg;
wire [12:0] seg;
output segdp;
wire segdp;
input [7:0] dip_sw;
input reset_n;
input clk_in;

reg [7:0] iptr;
reg [7:0] pb_read;
reg [7:0] pa_addr;
reg [7:0] pb_addr;
reg [7:0] data_out;
reg pa_clk;
reg [7:0] data_gen;
reg [2:0] state;
reg enable_gen;
reg enable_cmp;
reg pa_we;
reg reset;
reg pb_clk;
reg [7:0] data_cmp;
reg err;
reg [7:0] pa_write;
reg [31:0] counter;
reg act;
reg [7:0] optr;
reg [7:0] dual_raw_v10_a_read;
reg lfsr81_fb;
reg [7:0] lfsr81_v;
reg lfsr80_fb;
reg [7:0] lfsr80_v;
reg [7:0] dual_raw_v10_mem [0:256-1];



always @(posedge pb_clk) begin: TOP_DUAL_RAW_V10_PORT_B_PROC
    pb_read <= dual_raw_v10_mem[pb_addr];
end


always @(posedge pa_clk) begin: TOP_DUAL_RAW_V10_PORT_A_PROC
    if ((pa_we == 1)) begin
        
        dual_raw_v10_mem[pa_addr] <= pa_write;
    end
    dual_raw_v10_a_read <= dual_raw_v10_mem[pa_addr];
end



assign oled = {(~err), 6'h3f, act};
assign seg = 255;
assign segdp = 1;


always @(posedge clk_in) begin: TOP_LFSR81_WORKER
    if (reset == 1) begin
        lfsr81_v <= 34;
    end
    else begin
        if ((enable_cmp == 1)) begin
            lfsr81_v <= {lfsr81_v[6], lfsr81_v[5], lfsr81_v[4], (lfsr81_v[3] ^ lfsr81_fb), (lfsr81_v[2] ^ lfsr81_fb), (lfsr81_v[1] ^ lfsr81_fb), lfsr81_v[0], lfsr81_fb};
        end
    end
end


always @(lfsr81_v) begin: TOP_LFSR81_ASSIGN
    reg e;
    e = (lfsr81_v[7-1:0] == 0);
    lfsr81_fb = (lfsr81_v[7] ^ e);
    data_cmp = lfsr81_v;
end


always @(posedge clk_in) begin: TOP_LFSR80_WORKER
    if (reset == 1) begin
        lfsr80_v <= 34;
    end
    else begin
        if ((enable_gen == 1)) begin
            lfsr80_v <= {lfsr80_v[6], lfsr80_v[5], lfsr80_v[4], (lfsr80_v[3] ^ lfsr80_fb), (lfsr80_v[2] ^ lfsr80_fb), (lfsr80_v[1] ^ lfsr80_fb), lfsr80_v[0], lfsr80_fb};
        end
    end
end


always @(lfsr80_v) begin: TOP_LFSR80_ASSIGN
    reg e;
    e = (lfsr80_v[7-1:0] == 0);
    lfsr80_fb = (lfsr80_v[7] ^ e);
    data_gen = lfsr80_v;
end


always @(posedge clk_in) begin: TOP_WORKER
    if ((reset == 1)) begin
        state <= 3'b000;
        iptr <= 0;
        optr <= 0;
        counter <= 0;
    end
    else begin
        case (state)
            3'b000: begin
                state <= 3'b001;
            end
            3'b001: begin
                state <= 3'b011;
            end
            3'b011: begin
                state <= 3'b010;
            end
            3'b010: begin
                state <= 3'b100;
            end
            3'b100: begin
                state <= 3'b101;
            end
            3'b110: begin
                state <= 3'b001;
            end
            3'b101: begin
                if ((data_cmp == data_out)) begin
                    state <= 3'b110;
                end
                else begin
                    state <= 3'b111;
                end
            end
            3'b111: begin
                // pass
            end
            default: begin
                // pass
            end
        endcase
        if ((pa_we == 1)) begin
            iptr <= (iptr + 1);
        end
        if ((state == 3'b100)) begin
            optr <= (optr + 1);
        end
        counter <= (counter + 1);
        act <= counter[24];
    end
end


always @(iptr, state, data_gen, pb_read, clk_in, reset_n, optr) begin: TOP_ASSIGN
    reg e;
    reset = (!reset_n);
    data_out = pb_read;
    pa_clk = clk_in;
    pb_clk = clk_in;
    pa_write = data_gen;
    pa_addr = iptr;
    pb_addr = optr;
    case (state)
        3'b010: begin
            enable_gen = 1;
            enable_cmp = 0;
        end
        3'b110: begin
            enable_gen = 0;
            enable_cmp = 1;
        end
        3'b100: begin
            enable_gen = 0;
            enable_cmp = 0;
        end
        default: begin
            enable_gen = 0;
            enable_cmp = 0;
        end
    endcase
    e = (state == 3'b111);
    err = e;
    pa_we = (state == 3'b011);
end

endmodule
